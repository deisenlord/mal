; bootstrap.mal - Add functionality to be loaded at runtime here.

; Tracing for functions, includes recursive level
(defmacro! trace-off (fn* [func] (list 'trace func (str func) false)))
(defmacro! trace-on  (fn* [func] (list 'trace func (str func) true)))

; Simple if with implict do, no else clause
(defmacro! when (fn* [test & body]
  (list 'if test (cons 'do body))))

(def! second (fn* [lst]
    (first (rest lst))
))

(def! notempty? (fn* [lst]
    (not (empty? lst))
))

(def! noteq (fn* [a b]
    (not (= a b))
))

(def! eq =)

; Increment a number, list or vector
(def! inc (fn* [x]
    (cond
        (list?   x)
	    (map (fn* [y] (+ 1 y)), x)
	    
	(vector? x)
	    (vec (map (fn* [y] (+ 1 y)), x))
	  
        (number? x)
	    (+ 1 x)

	:else
            (throw "inc: arg0 must be list, vector or number")
        )
    )
)
; ditto decrement
(def! dec (fn* [x]
    (cond
        (list?   x)
	    (map (fn* [y] (- 1 y)), x)
	    
	(vector? x)
	    (vec (map (fn* [y] (- 1 y)), x))
	  
        (number? x)
	    (- 1 x)

	:else
            (throw "dec: arg0 must be list, vector or number")
        )
    )
)

(def! reduce (fn* [f init xs]
      (if (empty? xs)
          init

	  (reduce f (f init (first xs)) (rest xs))
      )    
))

; Join a lists members as strings with given seperators
(def! join (fn* [sep alist]
    (cond
	(empty? alist)  ""
        "else"          (str (first alist) (if (= (count alist) 1) "" sep) (join sep (rest alist)))
    )
))

; serialization.mal - Serialize and deserialize data structures

; Add a variables/objects serialized value to a map for writing to a file
(defmacro! serialize-add (fn* [container obj objname] 
    (list 'assoc container objname (list 'str "'" (list 'pr-str obj)))
))

; Write a collection of serialized variables to a file
(def! serialize-write (fn* [path container]
    (spit path (pr-str container))
))

; Read a collection of serialized variables from a file, use -realize to restore individual values
(def! serialize-read (fn* [path]
    (if (fileexists? path)
        (eval (read-string (slurp path)))

        (throw (str "serialize-read: no such file '" path "'"))
    )
))

; Return the value of a serialized variable
(def! serialize-realize (fn* [container varname]
    (if (contains? container varname)
        (eval (read-string (get container varname)))
    
        (throw (str "serialize-realize: no such variable '" varname "' in container"))
    )
))

      
