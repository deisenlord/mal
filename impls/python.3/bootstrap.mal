; bootstrap.mal - Add functionality to be loaded at runtime here.

; Path list for finding source files
(def! *PATHLIB* ["." "./libmal" "/usr/local/lib/mal"])

; Simple if with implict do, no else clause
(defmacro! when (fn* [test & body]
  (list 'if test (cons 'do body))))

(defmacro! for (fn* [initlist test & body]
    `(let* ~initlist
         (while ~test
	     (do ~@body)
	 )
     )
))

(def! second (fn* [lst]
    (nth lst 1)
))

(def! third (fn* [lst]
    (nth lst 2)
))

(def! notempty? (fn* [lst]
    (not (empty? lst))
))

(def! noteq (fn* [a b]
    (not (= a b))
))

(def! eq (fn* [a b]
    (= a b)
))

(def! nil? (fn* [a]
    (= a nil)
))

(def! notnil? (fn* [a]
    (not (nil? a))
))

; Replace elements in a list, replacement values in map
(def! replace (fn* [amap alist]
    (if (empty? alist)
        ()
	(let* [e    (first alist)
	       v    (if (contains? amap e) (get amap e) e)]
	    (concat v (replace amap (rest alist)))
        )
    )
))

; Next two belong in a string namespace but are needed for require's implementation

; Join a lists members as strings with given seperators
(def! join (fn* [sep alist]
    (if (empty? alist)
        ""
        (str (first alist) (if (= (count alist) 1) "" sep) (join sep (rest alist)))
    )
))	  

; Replace character in string 
(def! replace-char (fn* [s old new]
    (join "" (replace (hash-map old new) (seq s)))     
))

; Find a file on a path list
(def! find-file (fn* [fname pathlist]
    (if (empty? pathlist)
        nil
	(let* [pathname (str (first pathlist) "/" fname)]
	    (if (fileexists? pathname)
	        pathname
		(find-file fname (rest pathlist))
	    )
	)
    )
))

; Find a file on the offical path list
(def! find-path (fn* [fname]
    (find-file fname *PATHLIB*)
))

; Load namespace
(defmacro! require (fn* [ns & options]
    (let* [opt   (apply hash-map options)
           fname (str (replace-char (str ns) "." "/") ".mal")
	   path  (find-path fname) ]
        (if (notnil? path)
	    (do
                (eval (read-string (str "(do " (slurp path) "\nnil)")))
	        (if (contains? opt :alias)
	            (ns-alias ns (get opt :alias))
	        )
		nil
	    )
	    (throw (str "require: cannot locate '" (str fname) "' on " (str *PATHLIB*))) 
        )
    )
))

; Tracing for functions, includes recursive level
(defmacro! trace-off (fn* [func] (list 'trace func (str func) false)))
(defmacro! trace-on  (fn* [func]  (list 'trace func (str func) true)))


; Increment a number, list or vector
(def! inc (fn* [x]
    (cond
        (list?   x)
	    (map (fn* [y] (+ 1 y)), x)
	    
	(vector? x)
	    (vec (map (fn* [y] (+ 1 y)), x))
	  
        (number? x)
	    (+ 1 x)

	:else
            (throw "inc: arg0 must be list, vector or number")
        )
    )
)
; ditto decrement
(def! dec (fn* [x]
    (cond
        (list?   x)
	    (map (fn* [y] (- y 1)), x)
	    
	(vector? x)
	    (vec (map (fn* [y] (- y 1)), x))
	  
        (number? x)
	    (- x 1)

	:else
            (throw "dec: arg0 must be list, vector or number")
        )
    )
)

(def! reduce (fn* [f init xs]
      (if (empty? xs)
          init

	  (reduce f (f init (first xs)) (rest xs))
      )    
))



; serialization.mal - Serialize and deserialize data structures

; Add a variables/objects serialized value to a map for writing to a file
(defmacro! serialize-add (fn* [container obj objname] 
    (list 'assoc container objname (list 'str "'" (list 'pr-str obj)))
))

; Write a collection of serialized variables to a file
(def! serialize-write (fn* [path container]
    (spit path (pr-str container))
))

; Read a collection of serialized variables from a file, use -realize to restore individual values
(def! serialize-read (fn* [path]
    (if (fileexists? path)
        (eval (read-string (slurp path)))

        (throw (str "serialize-read: no such file '" path "'"))
    )
))

; Return the value of a serialized variable
(def! serialize-realize (fn* [container varname]
    (if (contains? container varname)
        (eval b(read-string (get container varname)))
    
        (throw (str "serialize-realize: no such variable '" varname "' in container"))
    )
))

