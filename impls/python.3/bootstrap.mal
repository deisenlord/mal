; bootstrap.mal - Add functionality to be loaded at runtime here.

; Tracing for functions, includes recursive level
(defmacro! trace-off (fn* [func] (list 'trace func (str func) false)))
(defmacro! trace-on  (fn* [func] (list 'trace func (str func) true)))

; Simple if with implict do, no else clause
(defmacro! when (fn* [test & body]
  (list 'if test (cons 'do body))))

(def! second (fn* [lst]
    (first (rest lst))
))

; Increment a number, list or vector
(def! inc (fn* [x]
    (cond
        (list?   x)
	    (map (fn* [y] (+ 1 y)), x)
	    
	(vector? x)
	    (vec (map (fn* [y] (+ 1 y)), x))
	  
        (number? x)
	    (+ 1 x)

	:else
            (throw "inc: arg0 must be list, vector or number")
        )
    )
)
; ditto decrement
(def! dec (fn* [x]
    (cond
        (list?   x)
	    (map (fn* [y] (- 1 y)), x)
	    
	(vector? x)
	    (vec (map (fn* [y] (- 1 y)), x))
	  
        (number? x)
	    (- 1 x)

	:else
            (throw "dec: arg0 must be list, vector or number")
        )
    )
)

(def! reduce (fn* [f init xs]
      (if (empty? xs)
          init

	  (reduce f (f init (first xs)) (rest xs))
      )    
))

; Join a lists members as strings with given seperators
(def! join (fn* [sep alist]
    (cond
	(empty? alist)  ""
        "else"          (str (first alist) (if (= (count alist) 1) "" sep) (join sep (rest alist)))
    )
)
)
